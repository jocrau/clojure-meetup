include::header.adoc[]

== Accessing a deeply nested data structure

[source,clojure]
----
(def joe {:first-name "Jochen"
          :last-name  "Rau"
          :shoe-size  9
          :birth-date #inst"1971-03-15"
          :locations  [{:address "120 Pulpit Hill Rd"
                        :zip     "01002"
                        :city    "Amherst"
                        :status  ::current}
                       {:address "60 North Street"
                        :zip     "01018"
                        :city    "Hatfield"}]})
----

[source,clojure]
----
(get joe :first-name)
----

[source,clojure]
----
(get (get (get joe :locations) 0) :city)
----

[source,clojure]
----
(get-in joe [:locations 0 :city])
----

The `get-in` function accepts a third argument which is the default value.

Keywords are functions:

[source,clojure]
----
(:first-name joe)
----

Yes, that's weird, but incredibly helpful:

[source,clojure]
----
(map :city (:locations joe))
----

[source,clojure]
----
(first (filter (fn [location] (= (:status location) ::current)) (get joe :locations)))
----

== Adding and removing values

[source,clojure]
----
[(conj [:a :b] :c)
(conj '(:a :b) :c)
(conj #{:a :b} :c)
(conj #{:a :b} :b)
(conj {:a 1 :b 2} [:c 3])]
----

[source,clojure]
----
(assoc joe :first-name "Shawn")
joe
----

[source,clojure]
----
(update-in joe [:locations 0] dissoc :status)
joe
----

[source,clojure]
----
[(first [:a :b])
(first '(:a :b))
(first #{:a :b})
(first {:a 1 :b 2})]
----

[source,clojure]
----
(rest [:a :b :c])
----

include::footer.adoc[]
