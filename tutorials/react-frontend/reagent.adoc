== Reagent

[source]
----
(require '[reagent.core :as r])
----

A simple component:

[source,reagent]
----
[:div "Hello World!!"]
----

Let's create a sequence of components:

[source]
----
(for [name ["Jochen" "Alice" "Bob"]]
        [:li name])
----

And use them as content of another component:

[source,reagent]
----
[:ul (for [name ["Jochen" "Alice" "Bob"]]
        [:li name])]
----

Components in Reagent are pure functions that return components:

[source,reagent]
----
(defn hello-message [name]
  [:div "Hello " name "!"])

[hello-message "Jochen"]
----

Compare React JSX with Clojure Reagent:

[cols=2,frame=none,grid=none,stripes=none]
|===
h|React JSX
h|Reagent
a|
[source,jsx]
----
function HelloMessage(props) {
    return <div>Hello {props.name}</div>;
}

ReactDOM.render(
  <HelloMessage name="Taylor" />,
  klipse_container
);
----
a|
[source]
----
(defn hello-message [props]
  [:div "Hello " (:name props)])


(reagent.core/render-component
    [hello-message {:name "Taylor"}]
    js/klipse-container)
----
|===

A component can hold a local state:

[source,reagent]
----
(defn input-field []
  (let [state (r/atom "")]
    (fn []
      [:input {:type      "text"
               :value     (deref state)
               :on-change (fn [event]
                            (let [new-value (.. event -target -value)]
                              (js/console.info new-value)
                              (reset! state new-value)))}])))
----

Functions can be passed to a component:

[source,reagent]
----
(defn input-field [persist-value]
  (let [state (r/atom "")]
    (fn [persist-value]
      [:input {:type        "text"
               :value       (deref state)
               :on-change   #(reset! state (.. % -target -value))
               :on-key-down #(when (= (.-key %) "Enter")
                               (doto % (.stopPropagation) (.. -target blur)))
               :on-blur     #(persist-value (deref state))}])))

[input-field (fn [value] (js/alert (str "Persisted: " value)))]
----

