== Reagent

[source]
----
(ns tutorials.react-frontend
  (:require [reagent.core :as r]))
----

A simple component:

[source,reagent]
----
[:div "Hello World!!"]
----

Let's create a sequence of components:

[source]
----
(for [name ["Jochen" "Alice" "Bob"]]
        [:li name])
----

And use them as content of another component:

[source,reagent]
----
[:ul (for [name ["Jochen" "Alice" "Bob"]]
        [:li name])]
----

Components in Reagent are pure functions that return components:

[source,reagent]
----
(defn hello-message [name]
  [:div "Hello " name "!"])

[hello-message "Jochen"]
----

Compare React JSX with Clojure Reagent:

[cols=2,frame=none,grid=none,stripes=none]
|===
a|
.React JSX
[source,jsx]
----
function HelloMessage(props) {
    return <div>Hello {props.name}</div>;
}

ReactDOM.render(
  <HelloMessage name="Taylor" />,
  klipse_container
);
----
a|
.Reagent
[source]
----
(defn hello-message [props]
  [:div "Hello " (:name props)])


(reagent.core/render-component
    [hello-message {:name "Taylor"}]
    js/klipse-container)
----
|===

A component can hold a local state:


.React JSX
[source,jsx]
----
class InputField extends React.Component {
  constructor(props) {
    super(props);
    this.state = {value: props.initialValue};
  }

  render() {
    return (
      <input
        value={this.state.value}
        onChange={(e) => this.setState({value: "foo"})}
        />
    );
  }
}

ReactDOM.render(
  <InputField initialValue="Default Text" />,
  klipse_container
);
----

.Reagent
[source,reagent]
----
(defn input-field [props]
  (let [state (r/atom (:initial-value props))]
    (fn [props]
      [:input {:value     (deref state)
               :on-change (fn [event]
                            (let [new-value (.. event -target -value)]
                              (js/console.info new-value)
                              (reset! state new-value)))}])))

[input-field {:initial-value "Default Text"}]
----

Functions can be passed to a component:

[source,reagent]
----
(defn input-field [persist-value]
  (let [state (r/atom "")]
    (fn [persist-value]
      [:input {:value       (deref state)
               :on-change   #(reset! state (.. % -target -value))
               :on-key-down #(when (= (.-key %) "Enter")
                               (doto % (.stopPropagation) (.. -target blur)))
               :on-blur     #(persist-value (deref state))}])))

[input-field (fn [value] (js/alert (str "Persisted: " value)))]
----

