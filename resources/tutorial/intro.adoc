:docinfo: shared
:icons: font
:source-highlighter: coderay
:imagesdir: img
:presenter_name: Jochen Rau
:presenter_company: Infinite Cloud LLC
:presenter_twitter: jocrau
:presenter_email: jrau@infinitecloud.com
:copyright: by-sa

= Functional Programming
{presenter_name}, {presenter_company}

Paradigms and Real-World Use

== Basic Expressions and Evaluation

[source,clojure]
----
    1
    2.3
    1/3
    "Hello World"
    \a
    :foo
    :my.namespace/foo
    ::foo
    #uuid"01a38532-c3d2-4ad8-89fa-3a4f1ea3fe69"
    #inst"2016-10-09"
    true
    false
    nil
----

Try some expressions yourself:

[.eval-clojure]
--
    #inst"2016-10-09"
--


== Code

[.eval-clojure]
--
    (defn add3 [number] (+ number 3))
    (defn twice [fun number] (fun (fun number)))
    (twice add3 5)
--

== Vectors

[.eval-clojure]
--
    [1 2 "foo" :bar]
--

== Maps

A map consists of key-value pairs. Keys and values can be any clojure data (strings, numbers, other maps, etc.).

[.eval-clojure]
--
include::../../src/meetup/intro.clj[tags=simpleMap]
--

As a consequence, maps can be deeply nested.

[.eval-clojure]
--
include::../../src/meetup/intro.clj[tags=nestedMap]
--

== Set

A set of unordered, distinct elements. Try to add "foo" a second time.

[.eval-clojure]
--
include::../../src/meetup/intro.clj[tags=set]
--


== Vars (are not variables)

[.eval-clojure]
--
include::../../src/meetup/intro.clj[tags=def]
--



[.eval-clojure]
--
include::../../src/meetup/intro.clj[tags=localBinding]
--



[.eval-clojure]
--
include::../../src/meetup/intro.clj[tags=reDef]
--




== Reagent

First, let's require the Reagent library (which includes all the React dependencies).

[.eval-reagent]
--
    (require '[reagent.core :as r])
--

[.eval-reagent]
--
    (defn hello [name]
      [:p (str "Hello " name "!")])

    [hello "Klipse"]
--