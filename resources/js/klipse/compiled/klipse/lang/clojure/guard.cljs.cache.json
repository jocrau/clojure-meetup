["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:externs",["^ ","~$Object",["^ "],"~$confirm",["^ "]],"~:use-macros",["^ ","~$starts-with?","~$clojure.string","~$go","~$cljs.core.async.macros","~$dbg","~$gadjett.core","~$go-loop","^9","~$emits","~$cljs.compiler","~$*source-map-data*","^>","~$emit","^>"],"~:excludes",["~#set",[]],"~:name","~$klipse.lang.clojure.guard","~:imports",null,"~:requires",["^ ","~$klipse.utils","^G","~$ana","~$cljs.analyzer","^I","^I","~$s","^7","^7","^7","^>","^>","~$cljs.core.async","^J"],"~:cljs.spec/speced-vars",[],"~:uses",["^ ","~$timeout","^J","~$<!","^J","^6","^7","~$chan","^J","~$runonce","^G","^=","^>","^?","^>","^@","^>","~$put!","^J"],"~:defs",["^ ","~$*watchdog-tick*",["^ ","~:meta",["^ ","~:file","/Users/jocrau/dev/workspaces/klipse/src/klipse/lang/clojure/guard.cljs","~:line",20,"~:column",3,"~:end-line",20,"~:end-column",18,"~:doc","each time the watchdog has a chance to run, this var is set with the current time","~:dynamic",true],"^C","~$klipse.lang.clojure.guard/*watchdog-tick*","^U","/Users/jocrau/dev/workspaces/klipse/src/klipse/lang/clojure/guard.cljs","^Y",18,"^W",1,"^[",true,"^V",18,"^X",20,"~:tag","~$number","^Z","each time the watchdog has a chance to run, this var is set with the current time"],"~$min-max-eval-duration",["^ ","^C","~$klipse.lang.clojure.guard/min-max-eval-duration","^U","/Users/jocrau/dev/workspaces/klipse/src/klipse/lang/clojure/guard.cljs","^V",22,"^W",1,"^X",22,"^Y",27,"^T",["^ ","^U","/Users/jocrau/dev/workspaces/klipse/src/klipse/lang/clojure/guard.cljs","^V",22,"^W",6,"^X",22,"^Y",27],"^11","^12"],"~$watchdog-period",["^ ","^C","~$klipse.lang.clojure.guard/watchdog-period","^U","/Users/jocrau/dev/workspaces/klipse/src/klipse/lang/clojure/guard.cljs","^V",23,"^W",1,"^X",25,"^Y",18,"^Z","The number of msec for the watchdog period.\n            This value has to be much lower than min-max-eval-duration.","^T",["^ ","^U","/Users/jocrau/dev/workspaces/klipse/src/klipse/lang/clojure/guard.cljs","^V",25,"^W",3,"^X",25,"^Y",18,"^Z","The number of msec for the watchdog period.\n            This value has to be much lower than min-max-eval-duration."],"^11","^12"],"~$tick",["^ ","~:protocol-inline",null,"^T",["^ ","^U","/Users/jocrau/dev/workspaces/klipse/src/klipse/lang/clojure/guard.cljs","^V",27,"^W",7,"^X",27,"^Y",11,"~:arglists",["~#list",["~$quote",["^1:",[[]]]]]],"^C","~$klipse.lang.clojure.guard/tick","~:variadic",false,"^U","/Users/jocrau/dev/workspaces/klipse/src/klipse/lang/clojure/guard.cljs","^Y",11,"~:method-params",["^1:",[[]]],"~:protocol-impl",null,"~:arglists-meta",["^1:",[null,null]],"^W",1,"^V",27,"^X",27,"~:max-fixed-arity",0,"~:fn-var",true,"^19",["^1:",["^1;",["^1:",[[]]]]]],"~$run-watchdog*",["^ ","^18",null,"^T",["^ ","^U","/Users/jocrau/dev/workspaces/klipse/src/klipse/lang/clojure/guard.cljs","^V",30,"^W",7,"^X",30,"^Y",20,"^19",["^1:",["^1;",["^1:",[[]]]]],"^Z","reset the *watchdog-tick* to the current time once in a while"],"^C","~$klipse.lang.clojure.guard/run-watchdog*","^1=",false,"^U","/Users/jocrau/dev/workspaces/klipse/src/klipse/lang/clojure/guard.cljs","^Y",20,"^1>",["^1:",[[]]],"^1?",null,"^1@",["^1:",[null,null]],"^W",1,"^V",30,"^X",30,"^1A",0,"^1B",true,"^19",["^1:",["^1;",["^1:",[[]]]]],"^Z","reset the *watchdog-tick* to the current time once in a while"],"~$run-watchdog-once",["^ ","^C","~$klipse.lang.clojure.guard/run-watchdog-once","^U","/Users/jocrau/dev/workspaces/klipse/src/klipse/lang/clojure/guard.cljs","^V",39,"^W",1,"^X",39,"^Y",23,"^T",["^ ","^U","/Users/jocrau/dev/workspaces/klipse/src/klipse/lang/clojure/guard.cljs","^V",39,"^W",6,"^X",39,"^Y",23],"^11","~$any"],"~$watchdog",["^ ","^18",null,"^T",["^ ","^U","/Users/jocrau/dev/workspaces/klipse/src/klipse/lang/clojure/guard.cljs","^V",41,"^W",7,"^X",41,"^Y",15,"^19",["^1:",["^1;",["^1:",[[]]]]]],"^C","~$klipse.lang.clojure.guard/watchdog","^1=",false,"^U","/Users/jocrau/dev/workspaces/klipse/src/klipse/lang/clojure/guard.cljs","^Y",15,"^1>",["^1:",[[]]],"^1?",null,"^1@",["^1:",[null,null]],"^W",1,"^V",41,"^X",41,"^1A",0,"^1B",true,"^19",["^1:",["^1;",["^1:",[[]]]]]],"~$guard",["^ ","^18",null,"^T",["^ ","^U","/Users/jocrau/dev/workspaces/klipse/src/klipse/lang/clojure/guard.cljs","^V",46,"^W",3,"^X",46,"^Y",8,"~:export",true,"^19",["^1:",["^1;",["^1:",[["~$max-eval-duration"]]]]]],"^C","~$klipse.lang.clojure.guard/guard","^1=",false,"^U","/Users/jocrau/dev/workspaces/klipse/src/klipse/lang/clojure/guard.cljs","^Y",8,"^1>",["^1:",[["^1L"]]],"^1?",null,"^1K",true,"^1@",["^1:",[null,null]],"^W",1,"^V",45,"^X",46,"^1A",1,"^1B",true,"^19",["^1:",["^1;",["^1:",[["^1L"]]]]]],"~$my-emits",["^ ","^18",null,"^T",["^ ","^U","/Users/jocrau/dev/workspaces/klipse/src/klipse/lang/clojure/guard.cljs","^V",53,"^W",7,"^X",53,"^Y",15,"^19",["^1:",["^1;",["^1:",[["^1L","~$&","~$xs"]]]]],"^Z","same as cljs.compiler/emits with insertion of a `guard()` call before if and recur (emitted as continue) statement.\n\n  Limitations:\n  1. It doesn't prevent infinite loop in imported code e.g. (reduce + (range)\n  ","~:top-fn",["^ ","^1=",true,"^1A",1,"^1>",[["^1:",["^1L","^1O"]]],"^19",["^1:",[["^1L","~$&","^1O"]]],"^1@",["^1:",[null]]]],"^C","~$klipse.lang.clojure.guard/my-emits","^1=",true,"^U","/Users/jocrau/dev/workspaces/klipse/src/klipse/lang/clojure/guard.cljs","^Y",15,"^1P",["^ ","^1=",true,"^1A",1,"^1>",[["^1:",["^1L","^1O"]]],"^19",["^1:",[["^1L","~$&","^1O"]]],"^1@",["^1:",[null]]],"^1>",[["^1:",["^1L","^1O"]]],"^1?",null,"^1@",["^1:",[null]],"^W",1,"^V",53,"^X",53,"^1A",1,"^1B",true,"^19",["^1:",[["^1L","~$&","^1O"]]],"^Z","same as cljs.compiler/emits with insertion of a `guard()` call before if and recur (emitted as continue) statement.\n\n  Limitations:\n  1. It doesn't prevent infinite loop in imported code e.g. (reduce + (range)\n  "]],"~:cljs.spec/registry-ref",[],"~:require-macros",["^ ","~$gadjett","^;","^;","^;","^9","^9"],"~:cljs.analyzer/constants",["^ ","~:seen",["^B",["~:else","~:recur","~:gen-col"]],"~:order",["^1X","^1W","^1Y"]],"^Z","The basic idea is that the first time a klipse snippet's cljs is evaluated, we kick off a go-loop whose job is to wake up every 100ms and update *watchdog-tick* to say: this is the last time that i woke up!\n\n  And if (guard) gets run and notices that the watchdog hasn't been able to wake up within the last *max-eval-duration* milliseconds, it decides that we should kill the currently evaluating function, and does that by throwing an error.\n\n  and this doesn't kill go-loops created by users' snippet code, because those go-loops won't block the watchdog from running.\n  "]